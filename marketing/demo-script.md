# Scenery Demo Script (2:30)

**Engineer-to-Engineer Style**

---

## AI-GENERATED HOOK (0:00 - 0:22)

**VOICEOVER (AI-generated video playing):**
"With Google AI Studio, you can vibe code an entire app in a couple of seconds! But the moment someone asks to make a product video for it—you're back in the stone age. You screen record, edit frame by frame, and do it all over again every single time you push an update. That's why I built Scenery. Just connect your GitHub repo and WATCH as Gemini turns your real components into videos. No re-recording, no re-editing—JUST AUTOMATIC."

**SCREEN:**
- Scenery-generated video with spring animations
- Text overlays synced to voiceover

---

## FACE CAM: INTRO (0:22 - 0:35)

**YOU:**
"That video was generated by AI—I'll show you how in a sec. But first, let me walk you through what I actually built. Two pipelines, seven Gemini integrations, running on Fly.io with a separate Playwright worker for browser rendering. Let's start with the first pipeline: component discovery."

**WHY:** Sets up the two-pipeline structure. Casually drops infrastructure (Fly.io, Playwright worker).

---

## PIPELINE 1: COMPONENT DISCOVERY (0:35 - 1:10)

### Architecture (0:35 - 0:50)

**YOU (screen share - architecture diagram):**
"So component discovery. You give me a GitHub URL, I clone the repo, and run TypeScript AST parsing to extract every component's interface—props, types, everything. Then Gemini kicks in."

**SCREEN:**
```
COMPONENT DISCOVERY PIPELINE
────────────────────────────
GitHub URL
    ↓
Clone + AST Parse (TypeScript compiler API)
    ↓
[Gemini] Categorize (button, form, modal, etc.)
    ↓
[Gemini] Generate Demo Props (realistic values)
    ↓
Server Component Detection (190 patterns - Prisma, NextAuth, Drizzle...)
    ↓
[Gemini] Transform to Client-Safe (strip async/await, mock data)
    ↓
Playwright Worker (Fly.io) → Real Browser Render
    ↓
[Gemini] Tailwind → Inline CSS (for portability)
    ↓
Component Previews
```

**YOU:**
"We also support Server Components—Next.js async components that normally crash in the browser. I built a detection system with 190 patterns for Prisma, NextAuth, Drizzle, Clerk. When we detect one, Gemini transforms it to a client-safe version—removes the awaits, mocks the data, strips auth guards. Then we render in actual Chromium via a Playwright worker running on Fly."

**WHY:** Shows real engineering complexity. Specific numbers (190 patterns) add credibility. Mentions infrastructure.

### Live Demo (0:50 - 1:10)

**YOU:**
"Let me show you."

**SCREEN:**
```
0:50-0:55
- Click into project
- Click "Connect GitHub"
- Paste repo URL, loading starts
```

**YOU:**
"It's cloning, parsing, running through Gemini with structured output—not prompt-based JSON, actual schema validation. Near-zero malformed responses."

**SCREEN:**
```
0:55-1:05
- Components populate grid
- Click a component
- Show props panel with "AI Generated" badge
```

**YOU:**
"Every component gets categorized, props generated, and a real preview. Not mocked HTML—this is actual React running in a headless browser. And these props flow directly into the video editor."

**SCREEN:**
```
1:05-1:10
- Toggle a prop, preview updates
```

---

## PIPELINE 2: VIDEO GENERATION (1:10 - 1:50)

### Architecture (1:10 - 1:25)

**YOU:**
"Now the fun part—video generation. This is a four-agent system."

**SCREEN:**
```
VIDEO GENERATION PIPELINE
─────────────────────────
User Prompt: "Create a demo of our auth flow"
    ↓
[Gemini] DIRECTOR AGENT
    → Plans narrative arc (hook → features → CTA)
    → Scene breakdown with frame budgets
    → Outputs scene intents, not specifics
    ↓
[Gemini] SCENE PLANNER (parallel per scene)
    → Translates intent → concrete compositions
    → Element positions (1920x1080 canvas math)
    → Spring animation configs (damping, stiffness, mass)
    → Cursor tutorial paths with CSS selectors
    ↓
ASSEMBLY AGENT
    → Converts to absolute frame timings
    → Track ordering (z-index)
    → Component → preview HTML mapping
    ↓
[Gemini] REFINEMENT AGENT ←──────────────┐
    → Scores 0-100 across 5 criteria      │
    → If score < 90: generate patches ────┘
    → If score ≥ 90: proceed to render
    ↓
Remotion Export (MP4/WebM)
```

**YOU:**
"Director plans the narrative—hook, features, call-to-action. Scene Planner runs in parallel for each scene using Gemini's function calling to set positions, spring physics, cursor paths. Then Refinement Agent scores it. If it's below ninety, it doesn't just say 'try again'—it generates specific patches and re-evaluates. That feedback loop is the key innovation."

**WHY:** Shows multi-agent architecture depth. Mentions parallel execution, function calling. Explains WHY refinement loop matters.

### Live Demo (1:25 - 1:50)

**YOU:**
"Watch this."

**SCREEN:**
```
1:25-1:30
- In editor, select 2-3 components
- Type: "Create a product demo of our auth flow"
- Click generate
```

**YOU:**
"Four agents coordinating..."

**SCREEN:**
```
1:30-1:42
- Progress messages:
  → "Director: planning 3 scenes..."
  → "Scene Planner: designing animations..."
  → "Assembly: building timeline..."
  → "Refinement: 82/100 → applying patches..."
  → "Refinement: 91/100 ✓"
- Video preview appears
```

**YOU:**
"Eighty-two first pass. Patches applied. Ninety-one. Most AI tools are one-shot—you get output, if it's wrong, regenerate everything. Here the system critiques and fixes itself."

**SCREEN:**
```
1:42-1:50
- Play the generated video in preview
- Spring animations, component transitions visible
```

**YOU:**
"And that's rendering through Remotion—frame-accurate, deterministic. No dropped frames."

---

## AUTO-SYNC: THE KILLER FEATURE (1:50 - 2:15)

**YOU:**
"Okay but here's what makes this actually useful for teams."

**SCREEN:**
```
1:50-1:58
- Type in chat: "Slow down the transitions"
- Video updates
```

**YOU:**
"You can keep iterating through chat—targeted patches, not full regeneration. But the real thing..."

**SCREEN:**
```
1:58-2:05
- Show terminal or GitHub: "git push" or merged PR
- Click sync button in Scenery
- "Syncing..." → "2 components updated"
```

**YOU:**
"When you push to your repo—merge a PR, whatever—click sync. Scenery diffs the components, only re-runs AI on what changed, regenerates the previews. Your videos reference the live component HTML, so they update automatically."

**SCREEN:**
```
2:05-2:12
- Show component preview updating
- Show video preview reflecting change
```

**YOU:**
"No re-recording. No re-editing. Documentation that actually stays current."

---

## CLOSING (2:12 - 2:30)

**YOU (can be face cam):**
"So that's Scenery. Seven Gemini integrations—long context for full-file analysis, native JSON mode with schema validation, function calling for the agents, thinking mode for the HTML transformations. Two pipelines. Playwright worker on Fly. Remotion for export. The whole thing's open source."

**SCREEN:**
```
2:20-2:30
- Architecture diagram with all 7 Gemini nodes highlighted
- "Built with Gemini 3 + Remotion"
- URL: scenery-gemini3.fly.dev
- GitHub URL
```

---

## TIMING SUMMARY

| Section | Duration | End Time |
|---------|----------|----------|
| AI-Generated Hook | 22s | 0:22 |
| Face Cam Intro | 13s | 0:35 |
| Pipeline 1: Architecture | 15s | 0:50 |
| Pipeline 1: Demo | 20s | 1:10 |
| Pipeline 2: Architecture | 15s | 1:25 |
| Pipeline 2: Demo | 25s | 1:50 |
| Auto-Sync Feature | 25s | 2:15 |
| Closing | 15s | 2:30 |
| **Total** | **2:30** | |

---

## ENGINEERING POINTS TO HIT

Things that show real complexity:

- [ ] "190 patterns for Server Component detection" (specific number)
- [ ] "TypeScript AST parsing" (real technique)
- [ ] "Playwright worker running on Fly.io" (infrastructure)
- [ ] "Schema validation, not prompt-based JSON" (reliability)
- [ ] "Scene Planner runs in parallel" (optimization)
- [ ] "Spring physics—damping, stiffness, mass" (detail)
- [ ] "Feedback loop with patches, not regeneration" (innovation)
- [ ] "Frame-accurate, deterministic rendering" (quality)
- [ ] "Diffs components, only re-runs on changes" (efficiency)

---

## INFRASTRUCTURE MENTIONS

Casual drops throughout:

- [ ] "Running on Fly.io"
- [ ] "Separate Playwright worker for browser rendering"
- [ ] "Remotion for export"
- [ ] "Open source"

---

## GEMINI 3 FEATURES (for Technical Execution - 40%)

- [ ] "Long context" — full-file analysis
- [ ] "Structured output / Native JSON mode" — schema validation
- [ ] "Function calling" — agent orchestration
- [ ] "Thinking mode" — HTML transformations
- [ ] "Seven integrations" — say the number

---

## SUBMISSION CHECKLIST

- [ ] Demo video ≤ 3 minutes, on YouTube/Vimeo
- [ ] ~200 word write-up (SUBMISSION_NOTES.md)
- [ ] Public demo: scenery-gemini3.fly.dev
- [ ] Public repo: github.com/[your-repo]
- [ ] English audio
- [ ] Shows working demo
